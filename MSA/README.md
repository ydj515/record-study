# MSA

#### Monolithic Architecture
- 싱글모듈
> 모든 소스가 단일 모듈 내에 존재
> 응집성과 결합도 높음
> 최상위 싱글 패키지
> 유연성, 확장성이 제한적
> 간단하게 1개의 jar

- 멀티모듈 아키텍처
> 역할, 서비스 별로 모듈화
> 응집성과 결합도 낮음
> 최상위 멀티 패키지
> 유연성, 확장성이 비교적 좋음
> 간단하게 n개의 jar

- 장점
> 배포가 간단
> 비싼 서버 리소스를 최적화해서 사용이 가능
> 공통 모듈을 활용하기 쉬움

- 단점
> scale out이 어려움. (단일 db endpoint를 가지고 있어 의존성이 큼)
> 단순한 수정사항일 지라도 전체 어플리케이션 재기동 필요
> 장애시 전체 어플리케이션 영향을 받음

#### SOA
Service Oriented Architecture <br/>
Monolithic Architecture의 단점을 해결하고자 고안
> "서비스" 단위로 개발하고, 서비스 간 규격화된 프로토콜(인터페이스) 를 사용하여 통신
> 대개 동일한 기술 스택들을 가지고 서비스들을 개발하며, 각 서비스들간의 재사용이 목적.
> ESB(Enterprise Service Bus) 라는 개념을 통해, 요청에대해 어떤 서비스들을 호출할 지 캡슐화 된 Layer 존재
> 서비스 간 통합을 강조

#### SOA와 모놀리식 공통점
> shared db
> 모듈/서비스 간 규격화된 호출 방식 사용 (서비스 간 통합 관점)

#### SOA와 모놀리식 차이점
> soa는 독립적 배포 가능
> 트랜잭션 구현은 별개로 해야함
> 비즈니스 로직에 따라, 어떤 서비스를 호출할 지 결정하는 Layer 존재
> ESB의 관리

#### SOA 와 MSA 공통점
> 개발의 단위를 <b>서비스</b>로 인지
> 다른 서비스와 독립적으로 개발, 배포 가능
> SOA 에서는 ESB의 역활이 중요. MSA에서는 이러한 것이 단지 dumb pipe 의 기능만 작용하길 희망(중요 역활이 아닌 전달 그 자체로만의 역활만 수행)

#### SOA 와 MSA 차이점
> msa는 각 서비스는 각 서비스의 특성에 맞는 기술스택을 독립적으로 선택 가능

#### MSA
business capabilities를 확보하기 고안 <br/>
비즈니스에 따라 빠른 출시와 지속적 피드백을 가능하게 하는 설계 및 개발
아래의 기술들을 사용
- 감지(circuit breaker)
> a -> b -> c 로 갈때 b -> c로 가는 통로의 장애가 발생한다면 b -> c로 가는 통로를 막고 b -> c' 로 진행하게함. 또한 b -> c 로가는 통로의 복구가 된다면 다시 b -> c로 진행
- 복구(container ochestration, K8S)
> 복구. 컨테이너 등을 다루는 기술

- 의도치 않은 결과 방지(transaction, event driven)
> a -> b -> c 로 흘러갈 때 b->c 구간에 에러가 발생하면 b는 작업이 완료되었음을 return 받지 못함. 하나의 event 자체를 a, b, c 가 구독하는 상태이고 b에서 완료된 작업을 c가 구독하여 처리한다고 가정하였을 때 b->c 의 작업요청은 실패했을 지라도 c 자체의 작업은 성공하였다.(message broker가 고장나지않았다면. )
saga(보상 트랜잭션)

- 서비스간의 영향도(chaos test)
> 강제로 문제를 만들어보고 미리 실패해보고 테스트를 진행 ex) 복구하는 방법 등
> 미리 실패하는 테스트를 진행해보면 실패하는 루트를 찾아 미리 방지





![111](https://github.com/ydj515/record-study/assets/32935365/a543df58-78bd-492a-9098-642de33e6812)



[출처]
https://rubygarage.org/blog/monolith-soa-microservices-serverless